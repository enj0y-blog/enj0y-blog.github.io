<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Internet of Vehicles</title>
  
  
  <link href="http://enjoyvie.github.io.com/atom.xml" rel="self"/>
  
  <link href="http://enjoyvie.github.io.com/"/>
  <updated>2021-07-08T09:14:16.559Z</updated>
  <id>http://enjoyvie.github.io.com/</id>
  
  <author>
    <name>IOV_a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AUTOSAR</title>
    <link href="http://enjoyvie.github.io.com/2021/07/08/autosar/"/>
    <id>http://enjoyvie.github.io.com/2021/07/08/autosar/</id>
    <published>2021-07-08T09:09:22.046Z</published>
    <updated>2021-07-08T09:14:16.559Z</updated>
    
    <content type="html"><![CDATA[<p>AUTOSAR 提供了一套规范，描述了基本的软件模块，定义了应用程序接口，并基于标准化的交换格式构建了一个通用的开发方法。AUTOSAR分层软件架构提供的基础软件模块可用于不同制造商的车辆和不同供应商的电子元件，从而减少研发支出，掌握日益复杂的汽车电子和软件架构。</p><span id="more"></span><h3 id="AUTOSAR的背景介绍"><a href="#AUTOSAR的背景介绍" class="headerlink" title="AUTOSAR的背景介绍"></a>AUTOSAR的背景介绍</h3><p>AUTOSAR是AUTOmotive Open System Architecture（汽车开放系统架构）的首字母缩写，是由全球各大汽车整车厂、汽车零部件供应商、汽车电子软件系统公司联合建立的一套标准协议，是对汽车技术开发一百多年来的经验总结。从2003年起，拟定了一个符合汽车电子软件开发的、开放的以及标准化的软件架构。该架构旨在改善汽车电子系统软件的更新与交换，同时更方便有效地管理日趋复杂的汽车电子软件系统。AUTOSAR规范的运用使得不同结构的电子控制单元的接口特征标椎化，应用软件具备更好的可扩展性以及可移植性，能够实现对现有软件的重用，大大降低了重复性工作，缩短开发周期。<br>AUTOSAR成员之间开展合作的主要目标是：使基本系统功能以及接口标椎化，使软件开发合作伙伴之间能交换、转换和集成各自的车载网络功能，最大限度地提高车辆售后的软件更新和系统升级效率。有了这个标准，AUTOSAR可以把范例从一个基于ECU的系统转移到基于功能的系统进行设计开发，统筹技术和经济方面对不断增长的E/E复杂性的汽车软件开发的管理。由于AUTOSAR提倡“在标准上合作，在实现上竞争”的原则，其核心思想是“统一标准、分散实施、集中配置”，所以采用AUTOSAR将为OEM带来很多好处，使得他们对于软件采购和控制拥有更大和更灵活的权利。软件系统的开放化和标准化将使更多的软件供应商进入汽车电子软件行业，OEM将有更多的选择，这将有利于提高软件产品的质量。<br>AUTOSAR的计划目标主要有三个：<br>1）建立分层的体系架构<br>2）为应用程序的开发提供方法论<br>3）制定各种应用接口规范</p><h3 id="AUTOSAR的分层模型"><a href="#AUTOSAR的分层模型" class="headerlink" title="AUTOSAR的分层模型"></a>AUTOSAR的分层模型</h3><p>为了实现应用程序和硬件模块之间的分离，AUTOSAR架构被抽象成四层，由上至下依次为：应用层（Application Layer）、运行时环境层（Run Time Environment，即RTE）、基础软件层（Basic Software，即BSW），以及微控制器层（Microcontroller）。如下图所示。</p><p><img src="/2021/07/08/autosar/1.png" alt="AUTOSAR的分层模型"></p><p>AUTOSAR软件体系结构包含了完全独立于硬件的应用层（APP）和与硬件相关的基础软件层（BSW），并在两者中间设立了一个运行时环境（RTE），从而使两者分离，形成了一个分层体系架构。RTE是专门为应用软件（AUTOSAR软件组件和/或AUTOSAR传感器/执行器组件）提供通信服务的层。在RTE之上，软件架构风格从“分层”转变为“组件风格”。AUTOSAR软件组件通过RTE与其他组件（内部和/或内部ECU）或服务进行通信。所以，这样的分层结构带来两个最大的好处，一方面，OEM可以专注于开发特定的、有竞争力的应用层软件（位于RTE之上），另一方面，它使OEM所不关心的基础软件层（位于RTE之下）得到标准化。</p><h3 id="AUTOSAR的方法论"><a href="#AUTOSAR的方法论" class="headerlink" title="AUTOSAR的方法论"></a>AUTOSAR的方法论</h3><p>AUTOSAR为汽车电子软件系统开发过程定义了一套通用的技术方法，即AUTOSAR方法论。该方法描述了从系统底层配置到ECU可执行代码产生过程的设计步骤，如下图所示。</p><p><img src="/2021/07/08/autosar/2.png" alt="AUTOSAR的分层模型"></p><p>AUTOSAR设计和开发流程分为三个阶段：系统配置、ECU设计与配置阶段、代码生成阶段。<br>第一阶段：定义系统配置文件，这是系统设计者或架构师的任务。包括选择硬件和软件组件，定义整个系统的约束条件。AUTOSAR通过使用信息交换格式和模板描述文件来减少初始系统设计时的工作量。系统配置的输入是XML类型的文件，输出是系统配置描述文件，系统配置的主要作用是把软件组件的需求映射到ECU上。<br>第二阶段：根据系统配置描述文件提取单个ECU资源相关的信息，提取出来的信息生成ECU提取文件。根据这个提取文件对ECU进行配置，例如操作系统任务调度，必要的BSW模块及其配置，运行实体到任务的分配等，从而生成ECU配置描述文件。该描述文件包含了特定ECU的所有信息。<br>第三阶段：生成代码，是基于ECU配置描述文件指定的配置来产生代码、编译代码，并把相关代码链接起来形成可执行文件。<br>具体的开发流程如下：<br>编写系统配置输入描述文件<br>在AUTOSAR中，所有的描述文件都是XML类型的文件。系统配置输入文件包含三部分内容：<br>1）软件组件描述，定义了每个涉及的软件组件的接口内容，如数据类型，端口，接口等。<br>2）ECU资源描述，定义了每个ECU的资源需求，如处理器、存储器、外围设备、传感器和执行器等。<br>3）系统约束描述，定义了总线信号，软件组件间的拓扑结构和映射关系。<br>系统配置<br>系统配置的功能主要是在资源和时序关系的前提下，把软件组件映射到各个ECU上，然后借助系统配置生成器生成系统配置描述文件。这个描述文件包括总线映射之类的所有系统信息以及软件组件与某个ECU的映射关系。<br>提取特定ECU的描述<br>从系统配置描述文件中提取出与各个ECU相关的系统配置描述信息，提取的信息包括ECU通信矩阵、拓扑结构、映射到该ECU上的所有软件组件，并将这些信息放在各个ECU的提取文件中。<br>ECU配置<br>ECU配置主要是为该ECU添加必要的信息和数据，如任务调度、必要的基础软件模块及其配置、运行实体及任务分配等，并将结果保存在ECU配置描述文件中，该文件包含了属于特定ECU的所有信息，换言之，ECU上运行的软件可根据这些信息构造出来。<br>生成可执行文件<br>根据ECU配置描述文件中的配置信息，生成RTE和基础软件配置代码，完成基础软件和软件组件的集成，最终生成ECU的可执行代码。</p><h3 id="AUTOSAR的接口类型"><a href="#AUTOSAR的接口类型" class="headerlink" title="AUTOSAR的接口类型"></a>AUTOSAR的接口类型</h3><p>通过RTE实现AUTOSAR软件组件之间以及应用层与基础软件之间的通信前提是：软件组件之间必须有标准的AUTOSAR接口。AUTOSAR规范把汽车电子领域内的一些典型的应用划分为若干个由一个或多个软件组件组成的模块，并详细定义了这些软件组件相关的参数，例如名称、范围、类型等。<br>AUTOSAR定义了三种接口：标椎化接口（Standardized Interface）、AUTOSAR接口（AUTOSAR Interface）和标准化的AUTOSAR接口（Standardized AUTOSAR Interface）。<br>AUTOSAR接口是一种与应用相关的接口，与RTE一并生成。基于AUTOSAR接口的端口可以用于软件组件（Software Component,SWC）之间或者软件组件与ECU固件之间（例如复杂驱动）的通信；<br>标准化AUTOSAR接口是一种特殊的AUTOSAR接口。这些在AUTOSAR规范中定义过的接口被SWC用于访问AUTOSAR BSW模块提供的服务，比如ECU管理模块或者诊断事件管理模块；<br>标椎化接口是AUTOSAR规范中用C语言定义的API。这些接口用于ECU内部BSW模块之间，RTE和操作系统之间或者RTE和COM模块之间；</p><p><img src="/2021/07/08/autosar/3.png" alt="AUTOSAR结构图"></p><p>如图所示，基础软件之间通过标椎化接口进行数据通信和操作调用的。故基础软件之间可以相互调用各自的API函数，但是微控制器抽象层只能被ECU抽象层所调用，底层驱动信息通过ECU抽象层传递给服务层使用。</p><h3 id="AUTOSAR的基础软件层"><a href="#AUTOSAR的基础软件层" class="headerlink" title="AUTOSAR的基础软件层"></a>AUTOSAR的基础软件层</h3><p>在上述AUTOSAR的分层模型中，最重要也是最复杂的，莫过于基础软件层BSW了。所以，接下去会花大篇幅重点介绍一下这个BSW。<br>首先，对基础软件层BSW进行进一步的细分，划分为4层：微控制器抽象层，ECU抽象层，服务层以及复杂驱动层。其中：<br>微控制器抽象层（MicroController Abstraction Layer，即MCAL），它位于BSW的最底层，包含了跟硬件相关的驱动程序、软件模块与直接访问微控制器内部和外围的设备，可以用来访问内存、通信和I/O等；<br>ECU抽象层（ECU Abstraction Layer），位于微控制器抽象层之上，对接微控制器抽象层所提供的驱动程序，并同时包含对外部设备的驱动程序，然后负责向上提供统一的访问接口实现对通信、内存或者I/O的访问，从而使得上层模块无须考虑这些资源由微处理器提供还是由外部设备提供；<br>服务层（Service Layer），提供各种类型的后台服务，例如网络服务、内存管理和总线通信服务等，操作系统就位于这一层。服务层是基础软件的最高层，同时与应用程序也有关联。虽然对I/O信号的访问由ECU抽象层覆盖，但服务层负责提供以下接口：操作系统的功能、车辆网络通信管理服务、存储器服务（NVRAM管理）、诊断服务（包括UDS通信、错误存储和故障处理）、ECU状态管理，模式管理、逻辑和时间程序流监控（Wdg管理器）、密码服务（密码服务管理）；<br>复杂驱动层（Complex Drivers Layer，即CCD），跨越于微控制器硬件层和RTE之间，其主要任务是整合具有特殊目的且不能用MCAL进行配置的非标准功能模块，将该部分功能嵌入到AUTOSAR基础软件层中，从而实现处理复杂传感器以及执行器的特定功能和时间要求，提供集成特殊用途的功能，例如设备驱动程序，在AUTOSAR中未规定的、具有非常高的时间限制或用于迁移等目的；<br>如下图所示：</p><p><img src="/2021/07/08/autosar/4.png" alt="AUTOSAR的分层模型"></p><p>所以，总结一下，基础软件层BSW的组件及其功能对应如下：<br>系统：提供标准化的规定（针对操作系统、定时器以及错误存储器）、ECU特定的服务（ECU状态管理、看门狗管理）和库函数；<br>内存：对内部和外部的内存（非易失性存储器）的访问入口进行标准化；<br>通信：对汽车网络系统、ECU通信系统以及ECU内部软件的访问入口进行标准化；<br>输入/输出：对传感器、执行器以及ECU外设的访问入口进行标准化；<br>同时，对BSW中的各个子层，还可以从功能上将其中的各个模块划分为4种类型，分别为驱动模块Driver、接口模块Interface、处理模块Handler以及管理器Manager。</p><p><img src="/2021/07/08/autosar/5.png" alt="AUTOSAR的复杂分层模型"></p><p>驱动模块Driver<br>驱动模块包含了控制和使用内部或者外部器件的功能，分为内部驱动和外部驱动。<br>1）内部驱动<br>内部器件位于微控制器（单片机）的内部，例如内部EEPROM、内部CAN控制器、内部ADC模块等。<br>内部驱动程序就是针对单片机内部器件资源的驱动程序，这部分驱动程序属于微控制器抽象层（MCAL）。<br>2）外部驱动<br>外部器件是指单片机外部的ECU硬件，比如外部EEPROM、外部看门狗、外部Flash等。外部驱动程序就是针对单片机外部硬件资源的驱动程序，属于ECU抽象层。外部驱动程序需要通过微控制器抽象层（MCAL）驱动程序来实现对外部器件的驱动。这种方法下AUTOSAR也支持嵌入在系统基础芯片（SBCs）中的组件，像收发器以及看门狗等。例如，使用SPI通信接口的外部EEPROM驱动程序是通过SPI总线处理程序来驱动外部EEPROM的。但是有一种例外，对于和内存映射相关的外部器件（如外部Flash存储器），其驱动程序是可以直接对微控制器进行存取访问的，所以这部分驱动程序属于微控制器抽象层（MCAL）。<br>接口模块Interface<br>接口模块包含了对其次级模块进行抽象的功能，比如对一个特定功能的硬件进行抽象。它提供一个通用的接口函数（API）来访问一种特定的器件类型，且与该类型器件的数目无关，同时也与器件的具体硬件实现无关。<br>接口模块不会改变数据的内容。一般来说，接口属于ECU抽象层。例如，CAN通信系统的接口模块提供一个通用的接口函数来访问CAN通信网络，并且与ECU上CAN控制器的数目以及硬件实现无关。<br>处理模块Handler<br>处理模块是一个专用的接口，它控制一个或多个客户端对一个或多个驱动程序进行并行、多重以及异步地访问。也就是说，它起着缓冲、队列、仲裁以及多路复用的功能。同时，处理程序也不会改变数据本身的内容。处理模块通常会并入驱动程序或是接口模块中（如SPIHandlerDriver、ADC Driver等）。<br>管理器Manager<br>管理器为多重的客户端提供特定的服务。当单纯的处理程序不能满足对多重的客户端进行抽象时，就需要用到管理器来进行处理。除了处理功能外，管理器还可以对数据内容进行评估、改变或是适应数据内容。<br>一般而言，管理器属于服务层。例如，非易失性随机存储器（NVRAM）的管理器负责对内部或是外部存储设备进行并行的访问，如Flash、EEPROM存储器等。同时，它也可以完成分布式并且可靠的数据存储、数据校验以及默认值的规定等。<br>从上面的划分角度出发，同时考虑到基础软件层主要用于向上提供基础软件服务，包括标准化的系统功能以及功能接口。所以，也可以从服务类型的角度，将上述4个子层更进一步的细分成一系列的基础服务软件组件，包括系统服务（System Services）、存储服务（Memory Services）、通信服务（Communication Services）、以及IO服务（I/O Services）等，如下图：</p><p>下面进行展开解释：<br>1、微控制器抽象层<br>微控制器器抽象层位于AUTOSAR分层模型中的BSW的最底层，它包含内部驱动，可以直接访问微控制器和片内外设。进一步的，MCAL又可分为微控制器驱动模块组（Microcontroller Drivers）、存储器驱动模块组（Memory Drivers）、通信驱动模块组（Communication Drivers）、以及I/O 驱动模块组（I/O Drivers）。各个部分又由具体的与微控制器硬件相对应的驱动模块组成，如下图：</p><p><img src="/2021/07/08/autosar/6.png" alt="AUTOSAR的抽象层"></p><p>1.1、微控制器驱动<br>微控制器驱动由通用定时器驱动（General Purpose Driver，GPT Driver）、看门狗驱动（Watchdog Driver，WDG Driver）、微控制器单元驱动（Microcontroller Unit Driver，MCU Driver）和内核测试（Core Test）四个部分组成。<br>1.1.1、GPT Driver<br>在AUTOSAR中有两类定时器，操作系统定时器和硬件定时器。该模块使用通用定时器单元的硬件定时器通道，为操作系统或者其他基础软件模块提供计时功能。一个典型的时间周期是50us-5ms。<br>GPT驱动的作用是：<br>启动和停止硬件定时器；<br>得到定时器数值；<br>控制时间触发的中断；<br>控制时间触发的中断唤醒。<br>1.1.2、WDG Driver<br>WDG Driver的功能主要是初始化和触发看门狗。WDG Driver有内部WDG Driver和外部WDG Driver。内部WDG Driver控制MCU的内部看门狗定时器，提供触发功能和模式选择服务；外部WDG Driver控制外部硬件看门狗，与内部WDG Driver一样，提供触发功能和模式选择服务。<br>1.1.3、MCU Driver<br>MCU Driver位于MCAL层，可以直接访问微控制器硬件，它的主要功能是初始化、休眠、复位微控制器以及提供其他MCAL软件模块所需的与微控制器相关的特殊功能。MCU Driver还能够使能并设置MCU时钟，例如CPU时钟、外围器件时钟、预分频器等参数。<br>1.1.4、Core Test<br>Core Test（内核测试）模块包含周期性测试和启动测试。内核测试模块可以对CPU所有寄存器进行测试，提供中断控制和异常检测。该模块还对算术逻辑单元、存储保护单元和缓存控制器等进行检测。<br>1.2、存储器驱动<br>存储器驱动由内部EEPROM驱动、内部Flash驱动、RAM测试和Flash测试四部分组成。<br>1.2.1、内部EEPROM驱动<br>内部EEPROM驱动提供初始化服务，以及对内部EEPROM的读写、写、擦除等操作。该驱动模块一次只能接受一个任务。<br>1.2.2、内部Flash驱动<br>内部Flash驱动提供内部Flash初始化服务，以及对内部Flash的读、写、擦除等操作。该驱动还可以将Flash访问代码下载到RAM中，如果需要的话，也可以执行写、擦除操作。<br>1.2.3、RAM测试<br>RAM测试模块通过软件对RAM存储进行测试。该模块包含后台测试和前台测试。其中，后台测试是异步服务，前台测试是同步服务。<br>1.2.4、Flash测试<br>flash测试模块提供算法来测试诸如数据/程序闪存、程序SRAM等非易失性存储器，这些存储器可以是集成在微控制器内部的，也可以是外部映射到微控制器的存储器。<br>1.3、通信驱动<br>通信驱动由以太网（Ethernet）驱动、FlexRay驱动、CAN驱动、LIN驱动和SPI驱动五部分组成。<br>1.3.1、Ethernet驱动<br>Ethernet驱动模块使用以太网驱动层访问某些控制器，对所使用的以太网控制器的硬件特性进行抽象，为上层的以太网使用提供统一的接口。可由由若干个以太网驱动模块复合起来组成。<br>1.3.2、FlexRay驱动<br>FlexRay驱动用来抽象不同的FlexRay通信控制器及其硬件相关的特性。通信控制器的FlexRay协议强制特性经过封装后只能通过统一的API进行访问。API提供了映射到基于实际通信控制器的硬件访问序列的抽象功能操作。因此，使用FlexRay驱动可以保证FlexRay接口独立于硬件。<br>对内部或外部FlexRay通信控制器的驱动来说，需要进行下列处理：<br>FlexRay控制器的初始化；<br>配置数据处理单元；<br>控制指令向通信控制器的传递；<br>从协议引擎到控制器主接口状态数据的规定；<br>通信控制器和主处理机之间信息数据的传输。<br>1.3.3、CAN驱动<br>CAN驱动针对的是微控制器内部的CAN控制器，它可以实现以下功能：<br>对CAN控制器进行初始化；<br>发送和接收报文；<br>对报文的数据和功能进行通知（对接收报文的指示、对发送报文的确认）；<br>溢出和错误处理；<br>唤醒检测；<br>此外，CAN驱动还具有以下特性：</p><p>单个或多个CAN通道；<br>CAN驱动的多重实例化；<br>对接收报文的中断/轮询模式；<br>CAN驱动是MCAL的一部分，可以执行硬件访问、向上层提供独立于硬件的API，而仅有的能够访问CAN驱动的上层是CAN接口（CAN Interface）。CAN驱动也可以为数据传输的初始化和通知接收事件的回调函数提供服务，该服务也是独立于硬件的。除此之外，CAN驱动也可以控制从属于同一个CAN硬件单元的CAN控制器的行为和状态。<br>1.3.4、LIN驱动<br>LIN驱动使用标准的通用异步收发器（Universal Asynchronous Receiver Transmitter，UART）或者串行通信接口（Serial Communication Interface，SCI）进行通信。<br>该模块可以完成下列任务：<br>LIN硬件的初始化：<br>调度表的处理；<br>LIN报文的发送（通过标志位和函数接口确认）；<br>LIN报文的接收（通过标志位和函数接口指示）；<br>睡眠和唤醒；<br>协议差错的处理；<br>报文的超时监测；<br>LIN驱动也是MCAL的一部分，可以执行硬件访问、向上层提供独立于硬件的API。仅有的能够访问LIN驱动的上层是LIN接口（LIN Interface）。一个LIN驱动可以支持多个通道，但是这些通道要属于同一个LIN硬件单元。<br>1.3.5SPI驱动<br>SPI驱动模块是微控制器内部同步通信串行接口的驱动。SPI驱动为SPI总线上不同的设备（如EEPROM/Watchdog等）提供读写访问服务。一个SPI设备可以被所使用的SPI硬件和相关的片选信号识别。该模块可以在主、从或者主-从模式下运行。<br>配置SPI驱动应遵循以下步骤：<br>选择SPI驱动的功能级别，配置可选择的功能特性；<br>根据数据用途来定义SPI通道，它们可以是SPI驱动的内部缓冲器，或者是由用户提供的外部缓冲器；<br>根据硬件属性来定义SPI任务，它们会包含一系列使用这些属性的通道；<br>最后定义任务序列，以优先级排序的方式来传递数据；<br>1.4、I/O驱动<br>I/O驱动由PORT驱动、DIO驱动、ADC驱动、PWM驱动、ICU驱动、OCU驱动六部分组成。<br>1.4.1、PORT驱动<br>PORT驱动初始化就是对微控制器的整个PORT模块进行初始化配置。<br>很多端口和管脚被分配有多种不同的功能，即可以进行引脚功能复用，比如通用I/O、模数转换、脉宽调制等功能。因此，对PORT必须有一个整体的配置和初始化，对各管脚的具体配置和使用取决于微控制器和ECU的引脚功能分配。PORT初始化数据应当尽可能高效地写到每个端口。DIO驱动中所用到的端口的配置和初始化都是在PORT驱动模块中完成的。因此，在使用DIO功能之前，应先进行PORT的初始化。<br>1.4.2、DIO驱动<br>DIO驱动对微控制器硬件管脚的访问进行了抽象，除此之外，还可以对管脚进行分组。该模块通过DIO通道、DIO端口以及DIO通道组来读写数据，而且这类操作是同步的。<br>1.4.3、ADC驱动<br>ADC驱动对微控制器内部模数转换单元进行初始化和控制。它可以提供启动和停止模数转换的服务，分别用来开启和禁用模数转换的触发源。<br>1.4.4、PWM驱动<br>PWM驱动为微控制器PWM模块提供初始化和控制服务，可生成周期和占空比都可变的脉冲。<br>1.4.5、ICU驱动<br>ICU驱动控制的是微控制器的输入捕获单元（Input Capture Unit），有两种模式：正常模式和休眠模式。<br>ICU驱动可以提供以下服务：<br>信号边沿检测及通知；<br>中断唤醒；<br>周期性信号时间的测量；<br>边沿时间戳捕获；<br>边沿/脉冲计数；<br>1.4.6OCU驱动<br>OCU驱动的作用是对微控制器内部的输出比较单元（Output Compare Unit）进行初始化和控制。当计数器的值到达某个阈值时，OCU模块会自动开始比较并执行相应的操作。<br>OCU驱动还可以为下列功能提供服务：<br>启动或停止输出通道；<br>设定某个阈值；<br>启用或禁用某个通道的通知函数；<br>获取计数器数值；<br>2、ECU抽象层<br>ECU抽象层负责提供统一的访问接口，实现对通信、内存或者IO口的访问，从而无须考虑这些资源是由微处理器提供的还是由外部设备提供的。外部设备的驱动就位于这一层。ECU抽象层主要包括板载设备抽象、存储器硬件抽象、通信硬件抽象以及IO硬件抽象4个部分。<br>2.1、I/O硬件抽象<br>I/O硬件抽象是一组模块从外设I/O设备（片上或板载）和ECU硬件布局（例如µC pin脚连接和信号电平倒置）抽象出来。I/O硬件抽象不会从传感器/执行器中抽象出来。不同的I/O设备可以通过I/O信号接口访问。<br>通信硬件抽象是一组模块从通信控制器和ECU硬件布局抽象出来。对于所有的通信系统都需要一个特定的通信硬件抽象（e.g. for LIN, CAN, FlexRay）。<br>例如：一个ECU微控制器有2个内部CAN通道和一个附加的板载带有4个CAN控制器的ASIC芯片，CAN-ASIC通过SPI方式连接微控制器。<br>通信驱动被访问通过总线特定的接口（CAN Interface）。<br>2.2、存储器硬件抽象<br>存储器硬件抽象是一组模块从外设存储设备（芯片或板载）和ECU硬件布局抽象出来。</p><p>例如：芯片上的EEPROM和外部的EEPROM设备都可以通过相同的机制访问。</p><p>存储设备被访问通过存储器特定的抽象/仿真模块（例如EEPROM 抽象）。</p><p>2.3、板载设备抽象<br>板载设备抽象包含ECU板载设备驱动，例如内部或外部看门狗，这些驱动访问ECU板载设备通过µC抽象层。</p><p>3、服务层<br>服务层是基础软件层的最高层，它可以实现与应用层软件的关联。I/O信号可以通过ECU抽象层进行获取，此外服务层还提供：操作系统功能、汽车网络通信以及管理功能、内存服务、诊断服务（包含统一诊断服务UDS，错误记忆和故障处理）、ECU状态和模式管理、逻辑与暂时程序流程监管（看门狗管理）、加密服务等；</p><p>服务层的主要任务是为应用程序、RTE以及基础软件模块提供最基本的服务。服务层的上层接口保证了微控制器和ECU硬件的独立。</p><p>按照服务对象的不同，服务层又分为三个部分，分别为通信服务，内存服务、和系统服务。</p><p>3.1、通信服务<br>通信服务是一组用于车辆网络通信的模块（CAN、LIN、FlexRay以及Ethernet）。通信服务通过通信硬件抽象来与通信驱动程序进行交互。其主要任务是为车辆通信网络和车载网络的诊断通道提供一个统一的接口，为网络管理提供统一的五福，以及从赢哦有那个程序中隐藏相关协议和消息属性。</p><p>3.1.1、CAN<br>CAN通信服务是一组带有CAN通信系统的车辆网络通信。为CAN网络提供统一的接口。应用程序中隐藏协议和消息属性。</p><p>CAN通信服务的实施与单片机和ECU硬件无关，但部分依赖于CAN通信本身；</p><p>AUTOSAR COM、Generic NM （Network Management）Interface 和 Diagnostic Communication Manager对于所有车辆网络系统都是相同的，并且每个ECU作为一个实例存在。</p><p>Generic NM Interface 只包含一个调度程序，不包含其他功能，对于网关ECUs，它还可以包括NM协调器功能，允许同步多个不同的网络（相同或不同类型的）同步唤醒它们或关闭他们。</p><p>CAN NM是针对特定CAN网络的，并且通过车辆CAN网络系统进行具体实现。可以通过底层网络适配器（CAN NM）与CAN Generic NM interfaces 连接。</p><p>通信系统特定的CAN状态管理器能够管控与通信系统相关的启动和关闭功能。此外，它还可以通过控制COM的不同选项来实现发送PDU以及监控信号超时的功能；</p><p>3.1.2、J1939<br>J1939通信服务是对普通CAN通信协议栈的拓展，主要应用在商用车上。其主要任务是提供J1939通信所需的协议服务，同时从应用程序中隐藏不需要的协议和消息属性。</p><p>J1939通信服务具有以下属性：</p><p>J1939通信服务的实施与单片机和ECU硬件无关，它是基于CAN通信的；<br>AUTOSAR COM、通用网络管理接口（Generic NM Interface）以及诊断通信管理器（Diagnostic Com.Manager）对所有的车辆网络系统都是通用的，并且作为每个ECU的一个实例而存在；<br>支持在配置阶段未知的动态帧标识符；<br>J1939网络管理器管控每一个ECU的特定地址分配，但它不支持休眠/唤醒处理以及其他相关的概念，如局部网络等；<br>提供J1939诊断和请求处理；<br>3.1.3、 LIN （LIN Master）<br>LIN通信服务是一组车辆LIN通信系统的模块。其主要任务是为LIN通信网络提供一套统一的接口，同时从应用程序中隐藏协议内容和消息属性。</p><p>LIN（主）通信服务具有以下属性：与LIN 2.1兼容的通信协议栈：调度表管理器，用于传输LIN帧和处理切换到其他调度表的请求；传输协议，用于诊断；一个唤醒和休眠接口；</p><p>底层LIN驱动：实现LIN协议并对特定硬件进行调整；支持简单的UART和基于LIN硬件的复杂框架；</p><p>Lin Interface 控制唤醒/休眠 API，并且允许从节点保持总线 awake （分散管理的方法 decentralized approach）；</p><p>通信系统特定LIN State Manager 依靠 Start-up 和 Shutdown 特性处理通信。此外，它还控制来自通信管理器的通信模式请求。LIN state manager 还通过接口COM 控制 I-PDU 组。</p><p>当发送LIN帧时，LIN接口需要数据的时刻（即在发送LIN帧之前）从PDU路由器请求帧（I-PDU）的数据。</p><p>3.1.4、Communication Services – LIN Slave<br>LIN Slave 通常是 “智能” 执行器，并且被视为黑盒。由于它们提供的硬件能力和资源非常少，并不打算将AUTOSAR软件组件转移到这样的系统上。因此，没有必要在LIN Slave 上安装AUTOSAR系统。</p><p>LIN Slave 可以连接为完整的ECUs。但他们不被迫使用AUTOSAR SW架构。也许他们可以使用同样标准的AUTOSAR模块（比如EEPROM，DIO）。</p><p>3.1.5、TCP/IP<br>TCP/IP通信服务是一组用于车辆TCP/IP通信系统的模块。其主要任务是为Ethernet通信网络提供一套统一的接口，同时从应用程序中隐藏协议内容和消息属性。</p><p>TCP/IP通信服务具有下属属性：TCP/IP模块实现TCP/IP协议家族（TCP/UDP/IPv4/IPv6/ARP/ICMP/DHCP）主要协议，并通过以太网（Ethernet）提供动态的、基于Socket的通信；Socket适配器模块是TCP/IP模块中的唯一上层模块；</p><p>3.2、存储器服务<br>Memory Services由一个模块组成，即 NVRAM 管理器。它负责非易失性（non volatile）数据的管理（从不同的内存驱动读/写）。向应用程序提供非易失性数据。提供非易失性数据管理机制，如保存、加载、校验和保护验证、可靠存储等。</p><p>3.3、系统服务<br>System Services 包含一组模块，并且模块的函数可以被所有层的模块使用。例如实时操作系统（包括定时器服务）和错误管理器。<br>其中一些服务是：µC相关的（如操作系统：OS），并可能支持特殊µC功能（如加密服务管理：Crypto Service Manager），部分ECU硬件和应用程序相关（如ECU状态管理器：ECU State Manager）等。</p><p>这些服务为应用程序和基本软件（BSW）模块提供基本服务。<br>4、复杂驱动层<br>复杂驱动（CCD）层跨越于微控制器硬件层和RTE之间，其主要任务是整合具有特殊目的且不能用MCAL进行配置的非标准功能模块，将该部分功能嵌入到AUTOSAR基础软件层中，从而实现处理复杂传感器以及执行器的特定功能和时间要求。<br>复杂驱动程序跟单片机和ECU硬件紧密相关。其上层程序接口是根据AUTOSAR指定并且实施的；其下层程序接口受标准接口程序的限制。<br>复杂驱动可以使用特定的中断或是复杂的微控制器外设（如PCP/TPU）来直接访问微控制器，从而实现对复杂传感器的评估和执行器的控制，比如喷油控制，电磁阀控制，增量位置检测等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AUTOSAR 提供了一套规范，描述了基本的软件模块，定义了应用程序接口，并基于标准化的交换格式构建了一个通用的开发方法。AUTOSAR分层软件架构提供的基础软件模块可用于不同制造商的车辆和不同供应商的电子元件，从而减少研发支出，掌握日益复杂的汽车电子和软件架构。&lt;/p&gt;</summary>
    
    
    
    <category term="车载网络" scheme="http://enjoyvie.github.io.com/categories/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="总线安全" scheme="http://enjoyvie.github.io.com/tags/%E6%80%BB%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CAN-FD</title>
    <link href="http://enjoyvie.github.io.com/2021/07/08/CAN-FD/"/>
    <id>http://enjoyvie.github.io.com/2021/07/08/CAN-FD/</id>
    <published>2021-07-08T07:25:05.083Z</published>
    <updated>2021-07-08T08:00:30.610Z</updated>
    
    <content type="html"><![CDATA[<p>当今社会，汽车已经成为了我们生活中不可缺少的一部分，人们希望汽车不仅仅是一种代步工具，更希望在汽车是生活及工作范围的一种延伸。在汽车上就像呆在自己的办公室和家里一样，可以打电话、上网、娱乐、工作。因此，汽车制造商为了提高产品竞争力，将越来越多功能集成到了汽车上。ECU（电子控制单元）大量地增加使总线负载率急剧增大，传统的CAN总线越来越显得力不从心。因此，CAN FD(CAN with Flexible Data-Rate)协议诞生了。</p><span id="more"></span><h3 id="CAN-FD的诞生"><a href="#CAN-FD的诞生" class="headerlink" title="CAN-FD的诞生"></a>CAN-FD的诞生</h3><p>随着电子、半导体、通讯等行业的快速发展，汽车电子智能化的诉求也越来越强，消费者希望驾驶动力性、舒适性、经济性以及娱乐性更强的汽车。汽车制造商为了提高产品竞争力，将越来越多的电子控制系统加入到汽车控制中，例如ESP（Electronic Stability Program，电子稳定程序）、PEPS（Passive Entry Passive Start无钥匙进入和启动系统）等。但是由于CAN总线的最高传输速率为1Mbit/s（通常汽车CAN系统的实际使用速率最高为500kbit/s），ECU（Electronic Control Unit，电子控制单元）的大量增加使总线负载率急剧增大以致造成网络拥堵，影响信息传输的可靠性和实时性。<br>不同的汽车，根据其级别、类型和配置的不同，ECU的数量和网络拓扑都不尽相同。图1所示的网络拓扑为经济型轿车中常见的网络拓扑，因为所有的ECU都在同一个CAN网段上，其总线负载率可能高达50～60%，而一般情况下，CAN总线负载率在30%左右时网络系统的性能相对较好，否则会增大报文延迟、降低系统的扩展性，尤其对于实时性要求较高的安全系统，高负载率甚至可能影响汽车行车安全；另一方面，CAN总线的位填充规则会对CRC(Cyclical Redundancy Check)造成干扰，引起错误帧漏检，使信息传输的可靠性达不到预期的设计要求，因此CAN总线将不能满足日益增长的汽车网络需求。<br>为解决带宽与可靠性的需求，有人提出在汽车网络中使用新的总线协议替代CAN总线，例如安全系统中使用FlexRay总线、娱乐系统中使用MOST总线，但需要重新开发控制器软硬件、重新设计车载网络系统等，这无疑会增加汽车制造商的开发成本，降低其市场竞争力，因此在目前车载网络系统的基础上对CAN总线进行改进显得尤其迫切。<br>2011年Bosch发布了CAN替代总线–CAN FD (CAN with Flexible Data-Rate) 1.1版。CAN FD比CAN总线的带宽更高，具有与CAN总线相似的控制器接口，这种相似性使ECU供应商不需要对ECU的软件部分做大规模修改，降低了开发难度和成本。CAN FD是CAN总线的升级换代设计，它继承了CAN总线的主要特性，提高了CAN总线的网络通信带宽，改善了错误帧漏检率，同时可以保持网络系统大部分软硬件特别是物理层不变。CAN FD协议充分利用CAN总线的保留位进行判断以及区分不同的帧格式[1]。在现有车载网络中应用CAN FD协议时，需要加入CAN FD控制器，但是CAN FD也可以参与到原来的CAN通信网络中，提高了网络系统的兼容性。</p><h3 id="CAN-FD帧格式"><a href="#CAN-FD帧格式" class="headerlink" title="CAN-FD帧格式"></a>CAN-FD帧格式</h3><p>引入CAN FD协议，对当前CAN网络系统物理层的改动较小，但是可以明显提高数据的串行通信速率， CAN-FD通过改变帧的格式增加总线带宽：一种方式为加长数据场长度减少报文数量降低总线负载率；另一种方式为缩短位时间提高位速率。CAN FD在数据帧内部采用两种不同的位速率，即在仲裁段（Arbitration-Phase）采用标准CAN位速率通信，在数据段（Data-Phase）采用高速率通信。<br>CAN-FD 数据帧在控制场新添加EDL位、BRS位、ESI位，采用了新的DLC编码方式、新的CRC算法（CRC场扩展到21位）。</p><p><img src="/2021/07/08/CAN-FD/%E5%B8%A7.png" alt="CAN-FD帧格式"></p><p>EDL位：（Extended Data Length）原CAN数据帧中的保留位r， 该位功能为：</p><ul><li>隐性： 表示CAN-FD 报文 （采用新的DLC编码和CRC算法）</li><li>显性： 表示CAN报文</li></ul><p>BRS位：（ Bit Rate Switch）该位功能为：</p><ul><li>隐性：表示转换可变速率</li><li>显性：表示不转换速率  </li></ul><p>ESI（Error State Indicator），该位的功能为： </p><ul><li>隐性：表示发送节点处于被动错误状态（Error Passive）</li><li>显性：表示发送节点处于主动错误状态（Error Active）</li></ul><p>EDL位可以表示CAN报文还是CAN-FD报文；BRS表示位速率转换，该位为隐性位时，从BRS位到CRC界定符使用转换速率传输，其他位场使用标准位速率，该位为显性时，以正常的CAN-FD总线速率传输；通过添加ESI位，可以很方便的知道当前发送节点所处的状态。<br>新的CRC算法。CAN总线由于位填充规则对CRC的干扰，造成错帧漏检率未达到设计意图。CAN-FD对CRC算法作了改变，即CRC以含填充位的位流进行计算。在校验和部分为避免再有连续位超过6个，就确定在第一位以及以后每4位添加一个填充位加以分割，这个填充位的值是上一位的反码，作为格式检查，如果填充位不是上一位的反码，就作出错处理。CAN-FD的CRC场扩展到了21位。由于数据场长度有很大变化区间，所以要根据DLC大小应用不同的CRC生成多项式，CRC_17，适合于帧长小于210位的帧，CRC_21，适适合于帧长小于1023位的帧。<br>新的DLC编码。CAN-FD 数据帧采用了新的新的DLC编码方式，在数据场长度在0-8个字节时，采用线性规则，数据场长度为12-64个字节时，使用非线性编码。</p><p><img src="/2021/07/08/CAN-FD/DLC.png" alt="DLC"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>　CAN FD是一种新协议，它保持了CAN协议的核心特征，并且拥有更高的带宽以及更长的数据长度，CAN FD在车载网络中可以沿用CAN总线的收发器，随着技术的发展也可以采用专用收发器，当采用CAN总线收发器时，其传输速率期望值为2.5 Mbit/s，相当于低速的FlexRay车载网络[5]。目前CAN FD还处于引入阶段，CAN FD通信可以用于特定用途，例如软件下载，此时其他不支持CAN FD的节点就保持睡眠状态。采用CAN FD协议的ECU无需改变应用程序以及CAN物理层便可用于现有网络系统，CAN网络向CAN FD网络过渡是简单方便而且易于实现的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当今社会，汽车已经成为了我们生活中不可缺少的一部分，人们希望汽车不仅仅是一种代步工具，更希望在汽车是生活及工作范围的一种延伸。在汽车上就像呆在自己的办公室和家里一样，可以打电话、上网、娱乐、工作。因此，汽车制造商为了提高产品竞争力，将越来越多功能集成到了汽车上。ECU（电子控制单元）大量地增加使总线负载率急剧增大，传统的CAN总线越来越显得力不从心。因此，CAN FD(CAN with Flexible Data-Rate)协议诞生了。&lt;/p&gt;</summary>
    
    
    
    <category term="车载网络" scheme="http://enjoyvie.github.io.com/categories/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="总线安全" scheme="http://enjoyvie.github.io.com/tags/%E6%80%BB%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Sybil攻击</title>
    <link href="http://enjoyvie.github.io.com/2021/07/07/sybil/"/>
    <id>http://enjoyvie.github.io.com/2021/07/07/sybil/</id>
    <published>2021-07-07T11:09:31.787Z</published>
    <updated>2021-07-07T11:36:29.347Z</updated>
    
    <content type="html"><![CDATA[<p>在传统的VANETS (Vehicle Ad-hoc Networks)向IoV (Internet of Vehicles)转变的过程中，车联网范围 不断扩大以及车联网内流量不断增加，使得传统入侵检测系统难以识别攻击信息或者无法及时给出反馈。 Sybil攻击作为车联网环境中的一种重要攻击类型，通过模拟正常车辆的运行特性造成道路信息混乱、阻 塞，为车辆的安全驾驶带来巨大挑战。本文面向车联网环境中的sybil攻击行为，使用基于流量统计的入 侵检测分析方法来对sybil攻击行为进行鉴别。在数据收集方面，利用仿真工具Veins模拟实际车联网环 境中的信息传输过程；在分类器选用方面，利用机器学习中的MLP (Multilayer Perceptron)神经网络， 训练能够识别sybil攻击的入侵检测模型；在可视化方面，设计具有便捷交互性的用户界面来进行展示和 预警。检测实验表明，本文所设计的入侵检测系统在区分正常流量和sybil攻击行为上平均达到了85%以 上的准确率，同时能够在可视化界面上及时地反馈预测结果。</p><span id="more"></span><h3 id="Sybil-攻击行为及其检测技术"><a href="#Sybil-攻击行为及其检测技术" class="headerlink" title="Sybil 攻击行为及其检测技术"></a>Sybil 攻击行为及其检测技术</h3><p>Sybil 攻击可以归类为 V2X (Vehicle to Everything)中最危险的和最难检测的攻击行为之一[1]。在 sybil攻击情形中，模拟车辆可以假装具有多个身份。换句话说，网络中的其他节点无法区分信息是来自一辆车辆还是来自多于一辆车辆。攻击者的主要目的是根据其目标来塑造网络。例如，攻击者可以操纵其他车辆的行为，使其他车辆偏离预定路线。除了是最危险的攻击形式之一之外，sybil 攻击也是最难发现的攻击之一。在使用地理路由的网络上，sybil 攻击更具风险，因为攻击者通过发送有关其位置的错误信息来声称车辆处于多个位置。此外，它还可以模拟发生在实际位置以外位置的事件。本小节将介绍 sybil 攻击的主要分类以及常用的 sybil 检测技术。</p><h4 id="Sybil-攻击分类"><a href="#Sybil-攻击分类" class="headerlink" title="Sybil 攻击分类"></a>Sybil 攻击分类</h4><p>车辆使用 IEEE 802.11p 网络(也称为 ITS-G5 网络)进行通信。所有车辆均使用 5.9 GHZ 频段定期广播 V2X 消息。每条消息都包含车辆的假名(临时身份)和一些运动学信息(位置、速度、前进方向等)。ITS (Intelligent Traffic System)中 PKI (Public Key Infrastructure)向车辆提供一个长期证书和几个短期证书，称 为假名证书。这些证书用于签署 V2X 消息。车辆经常更改其假名以避免跟踪并保护其隐私。每辆车在特 定时间段内使用单个假名证书进行签名。<br>为了确保车辆连续发送 V2X 消息的能力，必须同时提供几个有效的假名给每个车辆。欧盟委员会建 议最多使用 100 个有效假名证书。当 ITS 的可用假名不足时，它将请求发送到 PKI，用新证书重新填充 证书池。按照规定，车辆在一定时间内不能使用多个假名证书来签署其消息。但是行为异常的车辆可能 有意同时使用多个有效的假名证书，以此模拟车联网中的幽灵节点(不存在但能被车联网中其他车辆感知 到的模拟节点)，这会导致 sybil 攻击。根据攻击者的目标，sybil 攻击可能采用不同的形式。将其分为 4 类：</p><ol><li>随机数据填充拒绝服务 sybil 攻击(Dos Random Sybil Attack) 如图 1 所示，攻击者使用随机数据创建消息，消息包含车辆的假名和运动学信息(位置、速度、前进 方向等)。攻击者对每个发送的消息使用不同的假名，并将此种消息发送到车联网环境中，使得正常车辆 接收到此类信息时，无法及时鉴定消息真伪，容易引发事故。</li><li>数据回送 sybil 攻击(Data Replay Sybil Attack) 如图 2 所示，此攻击误导入侵检测系统将合法车辆报告为恶意车辆。攻击者选择受害车辆，在接收 到受害者车辆的消息后，创建同样包含受害车辆运动学的消息，发送到车联网环境中，使得在其他正常 节点看来，同一时空位置具有两辆不同的车辆，且无法判断哪个为正常车辆，造成混乱。</li></ol><p><img src="/2021/07/07/sybil/1.png" alt="图1"></p><p><img src="/2021/07/07/sybil/2.png" alt="图2"></p><ol start="3"><li>破坏性拒绝服务 sybil 攻击(Dos Disruptive Sybil Attack) 此攻击是 Dos Random Sybil Attack 和 Data Replay Sybil Attack 的组合。如图 3 所示，攻击者在每个 消息中使用不同的假名，但不会用随机数据填充它们。相反，传输的消息是基于从相邻的正常节点接收 到的数据。此种攻击和 Data Replay Sybil Attack 之间的区别在于它没有跟随一名受害节点，攻击者收集 数据信息，在不定的时间内发送一连串数据包来模拟一个正常的车辆行驶流程。</li></ol><p><img src="/2021/07/07/sybil/3.png" alt="图3"></p><ol start="4"><li>交通拥堵 sybil 攻击(Grid Sybil Attack) 如图 4 所示，攻击者使用有效的假名来模拟多辆幽灵车辆。使得恶意车辆通信范围内的车辆接收到 虚假消息，并得出道路上发生拥堵的结论。攻击者可以智能地计算出幽灵车的运动数据，从而使假消息 具有合理性和连贯性。</li></ol><p><img src="/2021/07/07/sybil/4.png" alt="图4"></p><h4 id="常用的-sybil-攻击检测技术"><a href="#常用的-sybil-攻击检测技术" class="headerlink" title="常用的 sybil 攻击检测技术"></a>常用的 sybil 攻击检测技术</h4><p>Pouyan 等提出了三种检测本地 Sybil 攻击的方法：1) 资源测试方法，假定无线网络实体不能同时 在同一信道上发送和接收。这种检测方法在车载网络中无效，因为攻击者可能具有多个发送和接收消息 的渠道；2) 位置验证方法，假定车辆只能同时定位在一个位置，但在车联网中正常节点广播的数据包可 以进行一定程度的伪造，因此位置验证方法存在一定的缺陷，即无法判断幽灵节点是否为正常节点；3) 基 于加密和身份验证的方法,假定使用 PKI 足以检测不具备密钥的消息，但是具有有效密钥材料的合法实体 也可以执行 sybil 攻击<br>Ghaleb 等提出了一种基于人工神经网络的局部不良行为检测模型，使用一些特征来确定车辆是否 具有异常行为。但是仅利用从单一车辆捕获的信息进行本地检测是不够的，例如 Grid Sybil Attack 模拟的 幽灵节点均符合正常车辆的运行特征。因此需要一个可以访问更多不良行为报告的全局系统。<br>本文提出一个全局的检测系统来收集车联网内一段时间的流量信息，即通过流量统计的方式，判断局域网内发生的 sybil 攻击行为，并识别出恶意车辆，对恶意车辆进行监控和预警。</p><h4 id="基于流量统计的-sybil-入侵检测"><a href="#基于流量统计的-sybil-入侵检测" class="headerlink" title="基于流量统计的 sybil 入侵检测"></a>基于流量统计的 sybil 入侵检测</h4><p>由于车联网的车辆间信息交互的特点，车联网中每一个拥有身份标识的车辆均相当于一个无线网点， 其发送的消息或者其本身均能够被车联网中的其他车辆所感知。所以当一个车联网内的恶意节点在传输 攻击信息时，无法指定这个攻击信息是否直接发送给某个特定的车辆，也就是说，攻击行为是不具备定 向性的。在恶意节点周围的正常节点均能够接收到此攻击消息，因此，sybil 攻击通常会使得整个车联网 陷入混乱。而流量统计的方式从多个车辆角度来识别恶意节点，恰好契合攻击行为的不定向性，从全局 的角度收集车联网内部的流量信息，通过入侵检测模型判断是否发生 sybil 攻击，再对识别为 sybil 攻击 类型的信息进行统计，以此识别出恶意车辆。</p><h3 id="入侵检测系统架构和流程"><a href="#入侵检测系统架构和流程" class="headerlink" title="入侵检测系统架构和流程"></a>入侵检测系统架构和流程</h3><p>基于流量统计的车联网入侵检测系统整体架构由以下三个模块组成：数据收集模块、分类器模块和可视化模块，如图 5 所示。</p><ol><li>数据收集模块包含路边单元 RSU 和车联网中的正常节点。该模块收集车联网环境中车辆之间传递的消息信息，形成报文，并以报文的形式发送给分类器模块</li><li>分类器模块接收到数据后对数据进行预处理，并使用已经训练好的分类器进行分类判断，并将分类结果进行保存，同时保存发送此数据包的车辆身份标识；在此过程中收集到的车辆标识信息和发送的数据包信息均保存在全局入侵检测系统的数据模块中</li><li>可视化模块通过对数据模块内容进行提取和总结，显示进行恶意攻击的车辆信息和攻击类型，并且对识别的准确率加以统计，对各个攻击的预警级别也进行判断，统计的结果显示在可视化界面中。</li></ol><p><img src="/2021/07/07/sybil/5.png" alt="图5"></p><p>基于流量统计的车联网入侵检测流程如图 6 所示，主要包括数据获取、数据处理、机器学习入侵检 测和上报四个过程：首先收集车联网流量，进行流量特征置信度计算；再将收集到的流量信息内容进行 归一化、去重、下采样等数据预处理操作，得到较好的训练数据集和测试数据集，并以此来训练一个基 于 MLP 的入侵检测模型，用于识别攻击类型；最后将检测结果保存处理，用于可视化模块的显示功能。</p><p><img src="/2021/07/07/sybil/6.png" alt="图6"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在传统的VANETS (Vehicle Ad-hoc Networks)向IoV (Internet of Vehicles)转变的过程中，车联网范围 不断扩大以及车联网内流量不断增加，使得传统入侵检测系统难以识别攻击信息或者无法及时给出反馈。 Sybil攻击作为车联网环境中的一种重要攻击类型，通过模拟正常车辆的运行特性造成道路信息混乱、阻 塞，为车辆的安全驾驶带来巨大挑战。本文面向车联网环境中的sybil攻击行为，使用基于流量统计的入 侵检测分析方法来对sybil攻击行为进行鉴别。在数据收集方面，利用仿真工具Veins模拟实际车联网环 境中的信息传输过程；在分类器选用方面，利用机器学习中的MLP (Multilayer Perceptron)神经网络， 训练能够识别sybil攻击的入侵检测模型；在可视化方面，设计具有便捷交互性的用户界面来进行展示和 预警。检测实验表明，本文所设计的入侵检测系统在区分正常流量和sybil攻击行为上平均达到了85%以 上的准确率，同时能够在可视化界面上及时地反馈预测结果。&lt;/p&gt;</summary>
    
    
    
    <category term="V2X" scheme="http://enjoyvie.github.io.com/categories/V2X/"/>
    
    
    <category term="V2X安全" scheme="http://enjoyvie.github.io.com/tags/V2X%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>V2X_Base</title>
    <link href="http://enjoyvie.github.io.com/2021/07/07/V2X/"/>
    <id>http://enjoyvie.github.io.com/2021/07/07/V2X/</id>
    <published>2021-07-07T08:24:32.966Z</published>
    <updated>2021-07-07T11:10:25.570Z</updated>
    
    <content type="html"><![CDATA[<p>V2X，顾名思义就是vehicle-to-everything，其希望实现车辆与一切可能影响车辆的实体实现信息交互，目的是减少事故发生，减缓交通拥堵，降低环境污染以及提供其他信息服务。</p><span id="more"></span><h3 id="V2X分类"><a href="#V2X分类" class="headerlink" title="V2X分类"></a>V2X分类</h3><ul><li>车辆与车辆V2V(Vehicle-to-Vehicle)：常见应用如防碰撞安全系统</li><li>车辆与基础设施V2I(Vehicle-to-Infrastructure)：交通信号指示与时间提醒</li><li>车辆与行人V2P(Vehicle-to-Pedestrian)：行人单车安全距离警报  </li><li>车辆与外部网络V2N(Vehicle-to-Network)：实时地图，云服务等</li></ul><p><img src="/2021/07/07/V2X/V2X.jpg" alt="V2X分类">    </p><h3 id="V2X使用的技术"><a href="#V2X使用的技术" class="headerlink" title="V2X使用的技术"></a>V2X使用的技术</h3><h4 id="1-DSRC技术"><a href="#1-DSRC技术" class="headerlink" title="1. DSRC技术"></a>1. DSRC技术</h4><p>DSRC技术的产生基于三套标准：</p><ul><li>第一个是IEEE 1609，标题为“车载环境无线接入标准系列（WAVE）”，其定义了网络的架构和流程。</li><li>第二个是SAE J2735和SAE J2945，它们定义了消息包中携带的信息。该数据将包括来自汽车上的传感器的信息，例如位置，行进方向，速度和刹车信息。</li><li>第三个标准是IEEE 802.11p，它定义了汽车相关的“专用短距离通信”（DSRC）的物理标准。DSRC顶层协议栈是基于IEEE 1609标准开发的，V2V信息交互是使用轻量WSMP（WAVE Short Message Protocol）而不是WIFI使用的TCP/IP协议，TCP/IP协议用于V2I和V2N信息交互。DSRC底层、物理层和无线链路控制是基于IEEE 802.11p。使用IEEE 802.11系列标准的初心是利用WIFI的生态系统，但是WIFI最初设计用于固定通讯设备，后来制定IEEE 802.11p支持移动通讯设备。（</li></ul><p><img src="/2021/07/07/V2X/dsrc.jpg" alt="DSRC协议栈"></p><p>尽管DSRC技术发展早，并且得到了广泛的实际验证和应用，但是也存在局限性：</p><ul><li>DSRC采用载波监听多路访问协议，在高密度的交通情况下会出现数据包译码失败的可能</li><li>DSRC物理成的正交频分复用技术限制了最大的传输功率和传输范围</li><li>DSRC属于视距传输技术，障碍物较多的城市工况对其构成挑战</li></ul><h4 id="2-C-V2X技术"><a href="#2-C-V2X技术" class="headerlink" title="2. C-V2X技术"></a>2. C-V2X技术</h4><p>针对DSRC技术可能存在的问题，通信产业提出了C-V2X解决方案。C-V2X是一项利用和提高现有的长期演进技术（Long Term Evolution，LTE）特点及网络要素的信息技术，是3GPP Realease-14规范的一部分，该初始标准侧重于V2V通信，并逐渐增强对其他V2X操作场景的支持。目前3GPP组织已经完成了LTE-V2X的业务需求、网络架构、无线接入技术和V2V/V2X业务方面的研究和标准化，并将LTE-V2X标准立项申请提交到国际标准化组织ISO。2018年11月针对智能交通系统中的LTE-V2X应用ISO/DIS17515-3标准已经进入最终的国际标准草案阶段。</p><p>相比于DSRC技术，C-V2X具有独有的优势和特点，如图3所示。首先C-V2X物理层采用频分复用技术，提高了链路预算增益，能比DSRC提供更长的预警时间和2倍的通信范围；其次5G技术的导入以及移动生态系统的完善将为C-V2X制定清晰的技术演变路线支持；另外利用移动蜂窝技术，能够快速的实现C-V2X系统的商业化，并且和车载远程信息处理服务相结合，进一步提高效率、降低成本。</p><p><img src="/2021/07/07/V2X/%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94.jpg" alt="DSRC与C-V2X特点对比"><br>然而目前C-V2X的基础技术LTE还存在不足：</p><ul><li><p>目前蜂窝网络难以达到毫秒级的低延迟</p></li><li><p>LTE采用增强型多媒体广播多波等技术进行单点到多点的接口管理，但是主要支持静态场景，对于车辆拥挤的情况可能无法提供所需的效能；</p></li></ul><p>未来5G将充分考虑这方面的特殊场景，针对汽车使用场景，5G V2X将具备如下特点：</p><ul><li><p>采用毫米波频谱提升频谱带宽，实现超高速数据传输；</p></li><li><p>吞吐量达到1Gb/s以上，具有更好的网络覆盖均匀性；</p></li><li><p>实现毫秒级的端对端延迟；</p></li><li><p>实现穿透式增强现实，查看前方车辆反馈的视频，并发现弱势道路使用者；</p></li></ul><p>目前全球正在加紧制定5G国际技术标准，中国已于2017年展开5G第二阶段测试，在2018年进行大规模组网实验，于今年6月正式发放5G牌照，标志中国5G由试运行转至商用。由于LTE的V2X平滑演进至5G，基于LTE的C-V2X能够与未来5G进行复用。</p><p>欧洲和亚洲是C-V2X的积极倡导者，并且结成了各种旨在开发、测试，推进C-V2X的伙伴关系，包括法国“驶向5G”战略合作、德国“汽车连接未来一切”等。中国将V2X作为智能网联车和智能交通的一部分，纳入“中国制造2025”“互联网+”等国家战略。目前国内积极在开展5G车辆网方面的部署，北京积极推动5G车辆网重点示范应用城市，并且2020年将在重点区域完成5G车联网建设；2019年7月14日国内首个自动驾驶5G车联网示范区在在广州黄埔区开建；南京铁塔、开沃汽车和大唐移动合作，共同推荐5G智能网联汽车业务的合作。另外由于美国在继续使用DSRC还是使用C-V2X上存在分歧，丰田公司搁置了原定2021在美国车型部署DSRC技术。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;V2X，顾名思义就是vehicle-to-everything，其希望实现车辆与一切可能影响车辆的实体实现信息交互，目的是减少事故发生，减缓交通拥堵，降低环境污染以及提供其他信息服务。&lt;/p&gt;</summary>
    
    
    
    <category term="V2X" scheme="http://enjoyvie.github.io.com/categories/V2X/"/>
    
    
    <category term="V2X安全" scheme="http://enjoyvie.github.io.com/tags/V2X%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>LIN、CAN、FlexRay、MOST</title>
    <link href="http://enjoyvie.github.io.com/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/"/>
    <id>http://enjoyvie.github.io.com/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/</id>
    <published>2021-06-30T07:05:49.955Z</published>
    <updated>2021-07-07T08:54:02.095Z</updated>
    
    <content type="html"><![CDATA[<p>汽车中的电子部件越来越多，光是ECU就有几十个，这么多的电子单元都要进行信息交互。传统的点对点通信已经不能满足需求，因此必须要采用先进的总线技术。车用总线就是车载网络中底层的车用设备或车用仪表互联的通信网络。目前，有四种主流的车用总线：CAN总线、LIN总线、FlexRay总线和MOST总线</p><span id="more"></span><h3 id="LIN、CAN、FlexRay、MOST功能介绍"><a href="#LIN、CAN、FlexRay、MOST功能介绍" class="headerlink" title="LIN、CAN、FlexRay、MOST功能介绍"></a>LIN、CAN、FlexRay、MOST功能介绍</h3><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB.jpeg" alt="用一张表格来说明各种总线的区别"></p><h3 id="Lin总线"><a href="#Lin总线" class="headerlink" title="Lin总线"></a>Lin总线</h3><p>LIN（Local Interconnect Network）是面向汽车低端分布式应用的低成本（0.5美元），低速串行通信总线。它的目标是为现有汽车网络提供辅助功能，在不需要CAN总线的带宽和多功能的场合使用，降低成本。</p><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/lin%E6%80%BB%E7%BA%BF%E5%BA%94%E7%94%A8.jpeg" alt="Lin总线在汽车上的应用"></p><p>LIN联盟成立于1999年，并发布了LIN01.0版本。最初的成员有奥迪、宝马、克莱斯勒、摩托罗拉、博世、大众和沃尔沃等。</p><p>LIN相对于CAN的成本节省主要是由于采用单线传输、硅片中硬件或软件的低实现成本和无需在从属节点中使用石英或陶瓷谐振器。这些优点是以较低的带宽和受局限的单宿主总线访问方法为代价的。</p><p>LIN包含一个宿主节点和一个或多个从属节点。所有节点都包含一个被分解为发送和接收任务的从属通讯任务，而宿主节点还包含一个附加的宿主发送任务。在实时LIN中，通讯总是由宿主任务发起的。</p><p>除了宿主节点的命名之外，LIN网络中的节点不使用有关系统设置的任何信息。我们可以在不要求其它从属节点改变硬件和软件的情况下向LIN 中增加节点。</p><p>宿主节点发送一个包含同步中断、同步字节和消息识别码的消息报头。从属任务在收到和过滤识别码后被激活并开始消息响应的传输。响应包含两个、四个或八个数据字节和一个检查和(checksum)字节。报头和响应部分组成一个消息帧。</p><p>LIN总线上的所有通讯都由主机节点中的主机任务发起，主机任务根据进度表来确定当前的通讯内容，发送相应的帧头，并为报文帧分配帧通道。总线上的从机节点接收帧头之后，通过解读标识符来确定自己是否应该对当前通讯做出响应、做出何种响应。基于这种报文滤波方式，LIN可实现多种数据传输模式，且一个报文帧可以同时被多个节点接收利用。</p><p>LIN总线物理层采用单线连接，两个电控单元间的最大传输距离为40m。其总线驱动器和接收器的规范遵从改进的ISO 9141 单线标准。基于SCI/UART( 通用异步收发接口的单总线串行通信)协议；目前几乎所有的微控制器芯片上都有SCI/UART接口。低传输速率、小于20kb/s、采用NRZ编码。</p><h3 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h3><p>CAN（Controller Area Network）即控制器局域网，可以归属于工业现场总线的范畴，通常称为CAN bus，即CAN总线，是目前国际上应用最广泛的开放式现场总线之一。</p><p>CAN 最初出现在汽车工业中，80年代由德国Bosch公司最先提出。最初动机是为了解决现代汽车中庞大的电子控制装置之间的通讯，减少不断增加的信号线。</p><p>CAN总线是一种串行数据通信协议，其通信接口中集成了CAN协议的物理层和数据链路层功能，可完成对通信数据的成帧处理，包括位填充、数据块编码、循环冗余检验、优先级判别等项工作。</p><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/can.jpeg" alt="CAN总线原理"></p><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/can%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpeg" alt="CAN总线结构"></p><p>总结下，当一个节点要向其它节点发送数据时，该节点的CPU 将要发送的数据和自己的标识符传送给本节点的CAN芯片，并处于准备状态；当它收到总线分配时，转为发送报文状态。CAN 芯片将数据根据协议组织成一定的报文格式发出，这时，网上的其它节点处于接收状态。每个处于接收状态的节点对接收到的报文进行检测，判断这些报文是否是发给自己的，以确定是否接收它。</p><h3 id="FlexRay总线"><a href="#FlexRay总线" class="headerlink" title="FlexRay总线"></a>FlexRay总线</h3><p>FlexRay总线是由宝马、飞利浦、飞思卡尔和博世等公司共同制定的一种新型通信标准，专为车内联网而设计，采用基于时间触发机制，具有高带宽、容错性能好等特点，在实时性、可靠性和灵活性方面具有一定的优势。</p><p>FlexRay总线数据收发采取时间触发和事件触发的方式。利用时间触发通信时，网络中的各个节点都预先知道彼此将要进行通信的时间，接收器提前知道报文到达的时间，报文在总线上的时间可以预测出来。即便行车环境恶劣多变，干扰了系统传输，FlexRay协议也可以确保将信息延迟和抖动降至最低，尽可能保持传输的同步与可预测。这对需要持续及高速性能的应用(如线控刹车、线控转向等)来说，是非常重要的。</p><p>它采用了周期通信的方式，一个通信周期可以划分为静态部分、动态部分、特征窗和网络空闲时间4个部分。静态部分和动态部分用来传输总线数据，即FlexRay报文。特征窗用来发送唤醒特征符和媒介访问检测特征符。网络空闲时间用来实现分布式的时钟同步和节点参数的初始化。</p><p>FlexRay具有高速、可靠及安全的特点. FlexRay在物理上通过两条分开的总线通信，每一条的数据速率是10MBit/s。FlexRay还能够提供很多网络所不具有的可靠性特点。尤其是FlexRay具备的冗余通信能力可实现通过硬件完全复制网络配置，并进行进度监测。FlexRay同时提供灵活的配置，可支持各种拓扑，如总线、星型和混合拓扑。FlexRay本身不能确保系统安全，但它具备大量功能，可以支持以安全为导向的系统（如线控系统）的设计。</p><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/flexray.jpeg" alt="FlexRay总线应用"></p><p>宝马公司在07款X5系列车型的电子控制减震器系统中首次应用了FlexRay技术。此款车采用基于飞思卡尔的微控制器和恩智浦的收发器，可以监视有关车辆速度、纵向和横向加速度、方向盘角度、车身和轮胎加速度及行驶高度的数据，实现了更好的乘坐舒适性以及驾驶时的安全性和高速响应性，此外还将施加给轮胎的负荷变动以及底盘的振动均减至最小</p><h3 id="MOST总线"><a href="#MOST总线" class="headerlink" title="MOST总线"></a>MOST总线</h3><p>MOST 是一种专门针对车内使用而开发的、服 务于多媒体应用的数据总线技术。 MOST 表示“多媒体传输系统”。</p><p>MOST 总 线利用光脉冲传输数据。MOST 总线采用环形 结构。在环形总线内只能朝着一个方向传输数 据。</p><p>MOST的传输技术近似于公众交换式电话网络（Public Switched Telephone Network；PSTN），有着数据信道（Data Channel）与控制信道（Control Channel）的设计定义，控制信道即用来设定如何使用与收发数据信道。 一旦设定完成，资料就会持续地从发送处流向接收处，过程中不用再有进一步的封包处理程序，将运作机制如此设计，最适合用于实时性音讯、视讯串流传输。</p><p>MOST在制订上完全合乎ISO/OSI的7层数据通讯协议参考模型，而在网线连接上MOST采用环状拓朴，不过在更具严苛要求的传控应用上，MOST也允许改采星状（亦称放射状）或双环状的连接组态，此外每套MOST传控网络允许最多达64个的装置（节点）连接。</p><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/most.jpeg" alt="MOST总线组成"></p><p><img src="/2021/06/30/%E5%9B%9B%E5%A4%A7%E6%80%BB%E7%BA%BF/most2.jpeg" alt="MOST总线控制单元"></p><p>MOST也支持随插即用（Plug and Play；PnP）机制。</p><p>MOST总线基于环形拓扑，从而允许共享多个发送和接收器的数据。MOST总线主控器(通常位于汽车音响主机处)有助于数据采集，所以该网络可支持多个主拓扑结构，在一个网络上最多高达64个主设备。</p><p>MOST的总数据传输率为24.8Mbps，这已是将音视讯的串流资料与封包传控资料一并列计，在24.8 Mbps的频宽中还可区隔成60个传输信道、15个MPEG-1的视讯编码信道，这些可由传控设计者再行组态、规划与调配。</p><p>由于这些优点，MOST是汽车电子中应用最多的最佳多媒体传控网络。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CAN总线是中坚，LIN是CAN的副手，FlexRay是未来的希望，MOST则负责文化事业。这四种总线将在未来继续大放异彩。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;汽车中的电子部件越来越多，光是ECU就有几十个，这么多的电子单元都要进行信息交互。传统的点对点通信已经不能满足需求，因此必须要采用先进的总线技术。车用总线就是车载网络中底层的车用设备或车用仪表互联的通信网络。目前，有四种主流的车用总线：CAN总线、LIN总线、FlexRay总线和MOST总线&lt;/p&gt;</summary>
    
    
    
    <category term="车载网络" scheme="http://enjoyvie.github.io.com/categories/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="总线安全" scheme="http://enjoyvie.github.io.com/tags/%E6%80%BB%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CAN总线分析</title>
    <link href="http://enjoyvie.github.io.com/2021/06/24/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/"/>
    <id>http://enjoyvie.github.io.com/2021/06/24/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/</id>
    <published>2021-06-24T09:26:05.132Z</published>
    <updated>2021-07-07T08:54:10.938Z</updated>
    
    <content type="html"><![CDATA[<p>控制器局域网 (Controller Area Network，简称 CAN或者 CAN bus) 是一种功能丰富的车用总线标准。被设计用于在不需要主机（Host）的情况下，允许网络上的单片机和仪器相互通信。 它基于信息传递协议，设计之初在车辆上采用复用通讯线缆，以降低铜线使用量，后来也被其他行业所使用。它是由研发和生产汽车电子产品著称的德国 BOSCH公司开发的，是国际上应用最广泛的现场总线之一。 </p><span id="more"></span><h3 id="CAN的国际标准化"><a href="#CAN的国际标准化" class="headerlink" title="CAN的国际标准化"></a>CAN的国际标准化</h3><ul><li>ISO11898 定义为 高速 CAN 通信标准，通讯速度达 125Kbps ~ 1Mbps，总线最大长度 40m/1Mbps，连接单元数最大 30，属于闭环总线，终端电阻：120Ω。</li><li>ISO11519 - 2 定义为 低速 CAN 通信标准，通讯速度在 125Kbps以下，总线最大长度 1km/40Kbps，连接单元数最大 20，属于开环总线，终端电阻：2.2KΩ。</li></ul><h3 id="CAN总线拓扑图及架构"><a href="#CAN总线拓扑图及架构" class="headerlink" title="CAN总线拓扑图及架构"></a>CAN总线拓扑图及架构</h3><p>多个电子控制单元（ECU）和HOST分别连接到总线上。电子控制单元和HOST被称作节点（can node）。节点的复杂程度可以只是简单的输入输出设备，也可以是包含有 CAN交互器并搭载了软件的嵌入式组件。节点还可能是一个网关，允许普通计算机通过 USB或以太网端口与 CAN网络上的设备通信。</p><p><img src="/2021/06/24/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/CAN%E6%8B%93%E6%89%91.jpg" alt="CAN总线拓扑图及架构"></p><p>每个节点的组成包括：</p><ul><li>中央处理器、微处理器或主处理器：处理主机决定收到的信息的意思以及想要传输的信息。传感器、驱动器和控制设备可以与主处理器连接。</li><li>CAN控制器；通常是集成单片机的一部分，接收：CAN控制器将从总线上接收的串位字节存储直到整个消息可用，之后主处理器可以获取这个消息（通常由于 CAN控制器触发一个中断）。发送：主处理器发送传递信息到 CAN控制器，之后当总线空闲时将串位信息传递至总线。</li><li>CAN收发器；由 ISO11898-2/3介质访问单元（MAU）标准定义，接收：把数据流从CAN总线层转换成 CAN控制器可以使用的标准。 CAN控制器通常配有保护电路。传输：把来自 CAN控制器的数据流转换至 CAN总线层。</li></ul><h3 id="CAN信号"><a href="#CAN信号" class="headerlink" title="CAN信号"></a>CAN信号</h3><p>CAN总线电平分为显性电平和隐性电平两种。总线上执行逻辑上的线 “与” 时，显性电平的逻辑值为 “0”，隐性电平为 “1”。<br> “显性” 具有 “优先” 的意味，只要有一个单元输出显性电平，总线上即为显性电平。并且，“隐性” 具有 “包容” 的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比隐性电平更强。）总线必须处于两种电平之一。<br>ISO11898标准（125kbps ~ 1Mbps）和 ISO11519 - 2标准（10kbps ~ 125kbps）</p><p><img src="/2021/06/24/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/can%E4%BF%A1%E5%8F%B7.png" alt="CAN信号"></p><h3 id="CAN的特点"><a href="#CAN的特点" class="headerlink" title="CAN的特点"></a>CAN的特点</h3><p>(1)多主控制<br>在总线空闲时，所有的单元都可开始发送消息（多主控制）。<br>最先访问总线的单元可获得发送权（CSMA/CA 方式 *1）。<br>多个单元同时开始发送时，发送高优先级 ID 消息的单元可获得发送权。<br>(2) 消息的发送<br>在 CAN 协议中，所有的消息都以固定的格式发送。总线空闲时，所有与总线相连的单元都可以开始发送新消息。两个以上的单元同时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作。<br>(3) 系统的柔软性<br>与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变。<br>(4) 通信速度<br>根据整个网络的规模，可设定适合的通信速度。<br>在同一网络中，所有单元必须设定成统一的通信速度。即使有一个单元的通信速度与其它的不一样，此单元也会输出错误信号，妨碍整个网络的通信。不同网络间则可以有不同的通信速度。<br>(5) 远程数据请求<br>可通过发送“遥控帧” 请求其他单元发送数据。<br>(6) 错误检测功能·错误通知功能·错误恢复功能<br>所有的单元都可以检测错误（错误检测功能）。<br>检测出错误的单元会立即同时通知其他所有单元（错误通知功能）。<br>正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止（错误恢复功能）。<br>(7) 故障封闭<br>CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。<br>(8) 连接<br>CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接<br>的单元数减少。</p><h3 id="CAN帧"><a href="#CAN帧" class="headerlink" title="CAN帧"></a>CAN帧</h3><ul><li>数据帧：用于发送单元向接收单元传送数据的帧；</li><li>远程帧：用于接收单元向具有相同标识符的发送单元请求数据的帧；</li><li>错误帧：用于当检测出错误时向其它单元通知错误的帧；</li><li>过载帧：用于接收单元通知其尚未做好接收准备的帧</li></ul><p>数据帧</p><p><img src="/2021/06/24/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%B8%A7.jpg" alt="数据帧"></p><p>图中示例标准数据帧（Standard）和扩展数据帧（Extended）两种格式。各字段定义及长度分别为：<br>SOF：表示数据帧开始；（1 bit）<br>Identifier：标准格式11 bit，扩展格式29 bit包括Base Identifier（11 bit）和Extended Identifier（18 bit），该区段标识数据帧的优先级，数值越小，优先级越高；<br>RTR：远程传输请求位，0时表示为数据帧，1表示为远程帧，也就是说RTR=1时，消息帧的Data Field为空；（1 bit）<br>IDE： 标识符扩展位，0时表示为标准格式，1表示为扩展格式；（1 bit）<br>DLC：数据长度代码，0<del>8表示数据长度为0</del>8 Byte；（4 bit）<br>Data Field：数据域；（0~8 Byte）<br>CRC Sequence：校验域，校验算法G(x) = x15 + x14 + x10 + x8 + x7 + x4 + x3 + 1；（15 bit）<br>DEL：校验域和应答域的隐性界定符；（1 bit）<br>ACK：应答，确认数据是否正常接收，所谓正常接收是指不含填充错误、格式错误、 CRC 错误。发送节点将此位为1，接收节点正常接收数据后将此位置为0；（1 bit）<br>SRR：替代远程请求位，在扩展格式中占位用，必须为1；（1 bit）<br>EOF：连续7个隐性位（1）表示帧结束；（7 bit）<br>ITM：帧间空间，Intermission (ITM)，又称Interframe Space (IFS)，连续3个隐性位，但它不属于数据帧。帧间空间是用于将数据帧和远程帧与前面的帧分离开来的帧。数据帧和远程帧可通过插入帧间空间将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。过载帧和错误帧前不能插入帧间空间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据以上信息得到以下结论：</p><ol><li>CAN总线传输的数据是未加密的数据</li><li>基于CAN总线的数据传输是无认证的</li><li>可以对基于CAN总线的传输进行模糊测试和数据重放攻击</li><li>基于CAN线的数据传输无安全机制</li></ol><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>CAN总线无安全保护措施，很容易受到攻击，因此未来的车辆网推出了SECoc等安全机制</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;控制器局域网 (Controller Area Network，简称 CAN或者 CAN bus) 是一种功能丰富的车用总线标准。被设计用于在不需要主机（Host）的情况下，允许网络上的单片机和仪器相互通信。 它基于信息传递协议，设计之初在车辆上采用复用通讯线缆，以降低铜线使用量，后来也被其他行业所使用。它是由研发和生产汽车电子产品著称的德国 BOSCH公司开发的，是国际上应用最广泛的现场总线之一。 &lt;/p&gt;</summary>
    
    
    
    <category term="车载网络" scheme="http://enjoyvie.github.io.com/categories/%E8%BD%A6%E8%BD%BD%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="总线安全" scheme="http://enjoyvie.github.io.com/tags/%E6%80%BB%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
